-- Dual Webhook Hatch Monitor (Server & Global Separate)
local TextChatService = game:GetService("TextChatService")
local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- Configuration
local SERVER_WEBHOOK = "https://discord.com/api/webhooks/1467126736516026464/_iBjbNFlzvekDjqPlKeI5u_LH_ywr--xkeNjAANxTTSUNFKn_fAWLduPcLxfrv0ClKal"
local GLOBAL_WEBHOOK = "https://discord.com/api/webhooks/1467126880510541825/W9K05DiKy_vw2VWlHosfwHoWvDfc7C4mz_fL5XQavcoeaqmDYaGNsclKyTmjXYMuYfgw"

-- Users that should ping @everyone in Global
local GLOBAL_PING_USERS = {
    "Raiden_Zel","WORST_HACHIMI","1LOVEYOURAIDEN_ei","2LOVEYOURAIDEN_ei",
    "WORST_3","4ILoveYouRaiden_ei","5ILoveYouRaiden_ei","6ILoveYouRaiden_ei",
    "7IloveYouRaiden_ei","8IloveYouRaiden_ei","9IloveYouRaiden_ei","Zelucifer"
}

-- Target user
local TARGET_USER = {
    Username = "Milocji2a",
    Nickname = "WORST_3",
    UserId = 5357478860
}

-- Verify user
local function verifyUser()
    local player = Players.LocalPlayer
    if not player then return false end
    return player.Name == TARGET_USER.Username
        and player.DisplayName == TARGET_USER.Nickname
        and player.UserId == TARGET_USER.UserId
end

-- Unauthorized GUI (AUTO CLOSE AFTER 10 SECONDS)
local function showUnauthorizedMessage()
    local player = Players.LocalPlayer
    local playerGui = player:WaitForChild("PlayerGui")

    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "UnauthorizedMessage"
    screenGui.Parent = playerGui

    local mainFrame = Instance.new("Frame")
    mainFrame.Size = UDim2.new(0.4, 0, 0.25, 0)
    mainFrame.Position = UDim2.new(0.3, 0, 0.375, 0)
    mainFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
    mainFrame.BorderColor3 = Color3.fromRGB(255, 50, 50)
    mainFrame.BorderSizePixel = 3
    mainFrame.Parent = screenGui

    local corner = Instance.new("UICorner", mainFrame)
    corner.CornerRadius = UDim.new(0.05, 0)

    local stroke = Instance.new("UIStroke", mainFrame)
    stroke.Color = Color3.fromRGB(255, 50, 50)
    stroke.Thickness = 2
    stroke.Transparency = 0.5

    local icon = Instance.new("ImageLabel", mainFrame)
    icon.Size = UDim2.new(0, 64, 0, 64)
    icon.Position = UDim2.new(0.5, -32, 0.2, -32)
    icon.Image = "rbxassetid://4432932767"
    icon.BackgroundTransparency = 1
    icon.ImageColor3 = Color3.fromRGB(255, 50, 50)

    local title = Instance.new("TextLabel", mainFrame)
    title.Size = UDim2.new(0.9, 0, 0.2, 0)
    title.Position = UDim2.new(0.05, 0, 0.45, 0)
    title.BackgroundTransparency = 1
    title.Text = "‚ö†Ô∏è UNAUTHORIZED ACCESS ‚ö†Ô∏è"
    title.TextColor3 = Color3.fromRGB(255, 50, 50)
    title.TextScaled = true
    title.Font = Enum.Font.GothamBold

    local msg = Instance.new("TextLabel", mainFrame)
    msg.Size = UDim2.new(0.9, 0, 0.4, 0)
    msg.Position = UDim2.new(0.05, 0, 0.65, 0)
    msg.BackgroundTransparency = 1
    msg.TextWrapped = true
    msg.TextScaled = true
    msg.Font = Enum.Font.Gotham
    msg.TextColor3 = Color3.new(1,1,1)
    msg.Text =
        "You are not authorized to run this script.\n\n" ..
        "Username: "..TARGET_USER.Username.."\n" ..
        "Nickname: "..TARGET_USER.Nickname.."\n" ..
        "UserId: "..TARGET_USER.UserId

    -- Pulse animation (auto disconnect)
    local t = 0
    local conn
    conn = RunService.Heartbeat:Connect(function(dt)
        if not screenGui.Parent then
            conn:Disconnect()
            return
        end
        t += dt
        local a = 0.5 + 0.5 * math.sin(t)
        stroke.Transparency = 1 - a
        icon.ImageTransparency = 0.5 - a * 0.5
    end)

    -- AUTO DESTROY AFTER 10 SECONDS
    task.delay(10, function()
        if screenGui and screenGui.Parent then
            screenGui:Destroy()
        end
    end)

    return screenGui
end

-- Authorization check
print("üîê Verifying user identity...")
if not verifyUser() then
    print("‚ùå Unauthorized user!")
    showUnauthorizedMessage()
    return
end

print("‚úÖ Authorized user verified!")

----------------------------------------------------------------
-- EVERYTHING BELOW IS YOUR ORIGINAL SCRIPT (UNCHANGED)
----------------------------------------------------------------

-- Store all hatches
local allHatches = {}
local totalHatches = 0
local serverHatches = 0
local globalHatches = 0
local userHatchCounts = {}

-- Clean text
local function cleanText(text)
    return text and text:gsub("<[^>]+>", ""):gsub("%s+", " "):gsub("^%s+", ""):gsub("%s+$", "") or ""
end

-- Extract username
local function extractUsername(message)
    return cleanText(message):match("([^%s]+)%s+hatched") or "Unknown"
end

-- Extract pet
local function extractPetInfo(message)
    local pet, rarity = cleanText(message):match("hatched a ([^(]+) %(([^)]+)%)")
    return pet or "Unknown Pet", rarity or "Unknown Rarity"
end

-- Global ping check
local function shouldPingInGlobal(username)
    for _, u in ipairs(GLOBAL_PING_USERS) do
        if u == username then return true end
    end
    return false
end

-- Send to Discord
local function sendHatchToDiscord(username, message, channel, isGlobal)
    userHatchCounts[username] = (userHatchCounts[username] or 0) + 1
    local webhook = isGlobal and GLOBAL_WEBHOOK or SERVER_WEBHOOK
    local pet, rarity = extractPetInfo(message)

    local data = {
        username = isGlobal and "üåê Global Hatch Monitor" or "üè† Server Hatch Monitor",
        embeds = {{
            title = "üê£ Hatch Detected",
            description = cleanText(message),
            color = 65280,
            fields = {
                {name="üë§ User", value=username, inline=true},
                {name="üêæ Pet", value=pet, inline=true},
                {name="‚≠ê Rarity", value=rarity, inline=true},
            },
            timestamp = DateTime.now():ToIsoDate()
        }}
    }

    pcall(function()
        http_request({
            Url = webhook,
            Method = "POST",
            Headers = {["Content-Type"]="application/json"},
            Body = HttpService:JSONEncode(data)
        })
    end)
end

-- Listen to chat
for _, channel in ipairs(TextChatService.TextChannels:GetChildren()) do
    if channel:IsA("TextChannel") then
        channel.OnIncomingMessage = function(msg)
            if msg and msg.Text and msg.Text:lower():find("hatched") then
                local username = extractUsername(msg.Text)
                local isGlobal = msg.Text:lower():find("global:")
                sendHatchToDiscord(username, msg.Text, channel.Name, isGlobal)
            end
        end
    end
end

print("‚úÖ Hatch monitor fully running")
